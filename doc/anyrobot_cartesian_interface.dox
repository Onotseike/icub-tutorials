/**
@page icub_anyrobot_cartesian_interface Customizing the Cartesian Interface for a Generic Robot

\author Ugo Pattacini

This tutorial will guide the user through the steps required to run all the components of the Cartesian Interface
with the purpose of controlling a generic yarp-compatible robot limb in its operational space. Therefore, this is
a somewhat advanced topic which might be of interest just for developers who want to adopt this interface for their
platforms, or for those of you who are really geek inside :). \n
For "normal" people - who have only iCub in their work life - the tutorial on the \ref icub_cartesian_interface
"Cartesian Interface" is extensive enough; it is also a prerequisite for proceeding further.


\section sec_architecture The Architecture

The architecture of the Cartesian Interface is sketched out below.

\image html cartIFArchitecture.jpg "The components of Cartesian Interface"

We already know there is a <b>solver</b> in charge of inverting the kinematics, a <b>server</b> controlling the robot
limb and finally a <b>client</b> enabling the user to forward requests for cartesian movements directly from within
the code through typical calls to C++ methods. \n
However, the diagram is more informative than that: it tells us about how these three components are arranged in the
iCub network, an allocation that should be preserved also for your robot's architecture to achieve fast and reliable
performances. Here follow the details. \n
- The solver is the most computational demanding tool; for this reason it should be launched on a powerful machine
  belonging to the cluster of PCs connected to the robot network. It employs Ipopt for nonlinear optimization and
  should not be a burden to any critical routine that has to control the robot in real-time. \n
  Nonetheless, having a powerful computer as own resource, the solver can tackle the inverse kinematics problem with
  a large number of degrees-of-freedom in near real-time (something like ~20 ms).
- The server is a canonical controller responsible for sending velocity commands to the robot with the purpose of
  achieving the joints configuration as found by the solver by moving the limb in a human-like fashion. It is a light-weight
  program so that it can run directly onboard the robot hub; it collects the requests coming from all the clients, it asks
  the solver to do its job and feeds back clients with useful information such as the current end-effector pose.\n
  The main reason why the server should be running on the hub is that the lag due to the communication must be reduced
  as much as possible since a lag in the control loop will inevitably cause for instance unwanted overshoots in the
  response. As final suggestion, consider placing the server physically close to the robot, that is where fast ethernet
  link ends (and yarp too) and the internal robot bus begins (e.g. CAN); for iCub indeed, the server runs aboard the
  PC104.
- The client simply lives inside the user code, making queries to the server through yarp ports, thus it never speaks
  to the solver. There are no special needs for it: the location of the client depends only on the requirements of the
  user code; a program that opens up a client may run on a shuffle PC so as on a powerful machine or even aboard the
  robot hub.


\section sec_dependencies Dependencies

Besides the "classical" dependecies you need to have in order to compile all the components (<a href="http://eris.liralab.it/wiki/Installing_IPOPT">Ipopt</a>,
\ref iKin, \ref servercartesiancontroller, \ref clientcartesiancontroller; you should know them very well by now :),
you are required to accomplish a preliminary job: it can be tedious (I realize it when I had to write the "fake" stuff :)
but is mandatory. You have to provide some low-level yarp motor interfaces that are necessary for the cartesian components
to start and operate correctly. They are only three: <b>IControlLimits</b>, <b>IEncoders</b>, <b>IVelocityControl</b>.
The former two serve to get the number of joints, their actual range along with current joints configuration which is fed
back to the controller; the latter is obviously employed to send velocity profiles to the robot. \n
This is not the right place where to tell about how to deal with these interfaces, but please find out more on the topic
of making a new device in yarp <a href="http://eris.liralab.it/wiki/Making_a_new_device_in_YARP">here</a>.


\section sec_custom_example Example of Customization

Let's explain how to configure all the components for your robot through an example, whose code is available under
\code
tutorials/src/anyRobotCartesianInterface.
\endcode
Imagine you're done with coding the basic motor interfaces for your robot, which is not as cute as iCub: it is equipped
indeed with just three degrees-of-freedom represented by three joints controlled by three independent motors. You'll probably
end up having something similar to the library <i>fakeMotorDevice</i> I wrote for our artifact. It contains the server and
client implementations of such motor interfaces: again, the IControlLimits, the IEncoders and the IVelocityControl.
Of course we would need now a program that simulates our fake manipulator together with the server layer that exposes a
yarp access to it. Here it is: it's called <i>fakeRobot</i> and instantiates three motors that are embodied as pure integrators
that give back joints positions once fed with joints velocities. \n
The relevant code snippet of this instantiation is located within the file <i>fakeMotorDeviceServer.cpp</i> and resumed here
for your convenience:
\code
Matrix lim(3,2);
lim(0,0)=-180; lim(0,1)=180;                    // joint 0 bounds [deg]
lim(1,0)=-90;  lim(1,1)=90;                     // joint 1 bounds [deg]
lim(2,0)=-45;  lim(2,1)=45;                     // joint 2 bounds [deg]

Vector q0;                                      // create a starting configuration q0
for (int i=0; i<lim.rows(); i++)
    q0.push_back((lim(i,0)+lim(i,1))/2.0);

motors=new Integrator(0.001*Ts,q0,lim);         // Ts is the period expressed in [ms]
\endcode
Aside from the details of the <i>Integrator</i> class (it is provided by the \ref ctrlLib library), it is worth noticing here
how the joints have bounds defined by the matrix <i>lim</i>.

Now, since you're so motivated, you've already got the kinematic description of the manipulator from your colleague who's hooked
on mechanics. You have to provide the conventional Denavit-Hartenberg table of links properties as done for the fake robot in the
file <i>app/conf/kinematics.ini</i>:
\code
numLinks 3      // number of revolute links: currently, iKin does not handle prismatic links

link_0 (A 1.0) (D 0.0) (alpha 0.0) (offset 0.0) (min -180.0) (max 180.0)
link_1 (A 1.0) (D 0.0) (alpha 0.0) (offset 0.0) (min -180.0) (max 180.0)
link_2 (A 1.0) (D 0.0) (alpha 0.0) (offset 0.0) (min -180.0) (max 180.0)
\endcode
The meaning of these parameters is described in the \ref iKinLink class; by the way they are easily recognized as the link length
(<i>A</i> in [m]), the link offset (<i>D</i> in [m]), the link twist (<i>alpha</i> in [rad]) and so on: please visit the wiki
<a href="http://eris.liralab.it/wiki/ICubForwardKinematics">page</a> on kinematics for a deeper insight. \n
A careful reader should have not missed the expression for the joints limits, which here can definitely take whatever values for all
the three joints, much different from the bounds assigned to the real joints and hard-coded within the fake motor device.
Do not worry about that: at start-up the solver will query the low-level interface (namely <i>IControlLimits</i>) about the actual
joints range and will update the kinematic structure accordingly. Later on, the server will get upgraded with a similar request
to the solver. \n

At this stage we are happy with the kinematics, so let's continue with the components configuration.


\section sec_solver_configuration Configuring the Solver

What is required here is only to inherit a new class from the iKin superclass <b>CartesianSolver</b> and then override the method
<i>getPartDesc()</i> which is responsible for describing all the parts used by the solver. \n
Essentially, you have to do the following four things: \n
-# Retrieve the configuration parameters;
-# Initialize the devices to access the motors;
-# Retrieve information about the kinematics;
-# Fill a descriptor to be returned to the superclass.

\subsection subsec_solver_confparams 1. Retrieving Configuration Parameters

The parameter of the <i>getPartDesc()</i> method is a <i>Searchable</i> object that should contain the initial configuration of the
solver as provided for instance through the file <i>solver.ini</i> whose content is listed just below. However, these values can be
easily modified at run-time through calls to the cartesian interface methods.
\code
robot          fake_robot               // the name of the robot to connect to
name           solver                   // the name of the solver as seen in yarp network
period         30                       // the period of the solver in [ms]
dof            (1 1 1)                  // the list of links status as they'll start off: if blocked(0) or dofs(1) - see iKin doc
rest_pos       (0.0 0.0 0.0)            // the joints resting positions as secondary task for the solver
rest_weights   (0.0 0.0 0.0)            // the weights of resting positions (0.0 means do not take that joint into account)
pose           full                     // [full] or [xyz] for position+orientation or just position
mode           shot                     // [shot] or [cont] for tracking mode off/on
verbosity      off                      // self-explaining :)
maxIter        200                      // stop solving whenever you overcome this limit
tol            0.0001                   // tolerance for the task
xyzTol         0.00000001               // tolerance for attaining in position [m^2]
interPoints    off                      // if [on] the points discovered while converging are provided as well: they might be not so adjacent
ping_robot_tmo 10.0                     // at start-up, while connecting to the robot, wait for this timeout in [s] before giving up
\endcode

\subsection subsec_solver_initdevices 2. Initializing Motor Devices

The solver must be aware of how to open a client to speak to motor device drivers. Prepare therefore as many <i>Property</i> objects
containing the suitable options as it is required by the manipulator: i.e. if the manipulator is composed of two parts (e.g. torso + arm),
prepare one <i>Property</i> for each part, filled with the instructions to open the corresponding motor client. \n
In the current example the fake manipulator is represented by just one motor part as it follows:
\code
Property optPart;
optPart.put("device","fakeyClient");                    // the name of the device
optPart.put("remote",(robot+"/"+part).c_str());         // the stem-name of the server remote yarp port
optPart.put("local",(slvName+"/"+part).c_str());        // the tag used as stem-name for the local ports
optPart.put("part",part.c_str());                       // just the name of the part for displaying purpose
\endcode

\subsection subsec_solver_kininfo 3. Retrieving Kinematics Info

There is a special key in the configuration file <i>solver.ini</i> which is missing: the one that tells the solver how to retrieve the
kinematics description. Its tag is "customKinFile" and must point to the <i>kinematics.ini</i> file. The path has to be absolute and
can be easily completed automatically by the <i>ResourceFinder</i> class - as you know: that's why we code it like the following:
\code
Property config;
config.fromConfigFile(rf.findFile("from").c_str());
config.put("customKinFile",pathToKin.c_str());
\endcode

We then build up the kinematic structure by populating an <i>iKinLimb</i> object with such information:
\code
Property linksOptions;
linksOptions.fromConfigFile(options.find("customKinFile").asString().c_str());
iKinLimb *limb=new iKinLimb(linksOptions);
\endcode

\subsection subsec_solver_filldesc 4. Filling the Descriptor

Finally, we need to provide a descriptor that in turn will be processed by the superclass:
\code
PartDescriptor *p=new PartDescriptor;
p->lmb=limb;                // a pointer to the iKinLimb
p->chn=limb->asChain();     // the associated iKinChain object
p->cns=NULL;                // any further (linear) constraints on the joints other than the bounds? This requires some more effort
p->prp.push_back(optPart);  // attach the options to open the device driver of the fake part
p->rvs.push_back(false);    // (*)
p->num=1;                   // only one device driver for the whole limb
\endcode
(*) It may happen that the motor commands to be sent are in reversed order with respect to the order of kinematics links as in the case
of the iCub torso; if so, push a "true" in the <i>rvs</i> field for the corresponding part.

Whenever a limb is actuated resorting to more than one device (e.g. for iCub: torso+arm), the following applies:
\code
p->prp.push_back(optTorso);
p->prp.push_back(optArm);
p->rvs.push_back(true);
p->rvs.push_back(false);
p->num=2;
\endcode
Intuitively, the insertion order depends on the links of the chain. In iCub the three links of torso come first, hence <i>optTorso</i> is
the first pushed object.


\section sec_server_configuration Configuring the Server

Coming to the server, life gets a bit easier. It is indeed required to open the device drivers of each involved part (in our case just
one, the "fake_part"), put them into a special list, open the <i>cartesiancontrollerserver</i> device passing the proper configuration
parameters that ensure the initialization of the kinematic structure, finally attach that list to such cartesian device. \n
The code is worth a thousand words ...
\code
Property optPart("(device fakeyClient)");        
optPart.put("device","fakeyClient");
optPart.put("remote","fake_robot/fake_part");
optPart.put("local","server/fake_part");
optPart.put("part","fake_part");

PolyDriver partDrv;
partDrv.open(optPart);                                          // open the device driver for the "fake_part"

Property optServer("(device cartesiancontrollerserver)");
optServer.fromConfigFile(rf.findFile("from").c_str(),false);    // init the server options from the ResourceFinder
Bottle &kinInfo=optServer.findGroup("GENERAL").addList();       // append something like "customKinFile <actual_file>"
kinInfo.addString("customKinFile");
kinInfo.addString(pathToKin.c_str());

PolyDriver server;
server.open(optServer);                                         // open the cartesian controller server

PolyDriverList list;
list.push(&partDrv,"fake_part");                                // fill the list with the given tag-name (see below)

IMultipleWrapper *wrapper;
server.view(wrapper);
wrapper->attachAll(list);                                       // attach the list
\endcode

The configuration parameters of the server are the following:
\code
[GENERAL]
ControllerName      server              // the yarp stem-name of the controller
ControllerPeriod    20                  // the period of the control thread
SolverNameToConnect solver              // the yarp stem-name of the solver to connect to
KinematicPart       custom              // this is a special keyword that tells the server to open custom kinematics
NumberOfDrivers     1                   // the number of parts composing the structure

[DRIVER_0]                              // here come the parameters for each part driver
Key                 fake_part           // the tag-name assigned to the part within the code
JointsOrder         direct              // the joints order: [direct] or [reversed] (see explanation \ref subsec_solver_filldesc "above")
MinAbsVels          (0.0 0.0 0.0)       // (*)
\endcode
(*) This is an optional parameter that accounts joint by joint for the minimum velocity (in [deg/s]) the motors can somehow achieve,
and are meant to be provided in absolute values. Whenever the controller tries to deliver velocities under these thresholds, then
it switches in a bang-bang mode to finally attain the target positions.


\section sec_client_configuration Configuring the Client

The client does not have to be aware of any particular implementation, thus it can be configured as documented in the \ref icub_cartesian_interface
"Cartesian Interface" page.


\section sec_final_notes Finals Notes about Compiling the Example

The example has been designed according to the packaging policy we pursue for iCub-based application: there is a <i>src</i> directory
filled with the library and the code and then there is an <i>app</i> directory containing the configuration files and the scripts
to run the binaries. Therefore, just create the <i>anyRobotCartesianInterface/build</i> directory (be always neat and divide the code
from the compilation products :), go there and launch the <i>ccmake ../</i> command. After the compilation you'll end up having the
directory <i>anyRobotCartesianInterface/bin</i> where all the binaries will be copied in, along with the configuration files and the
xml scripts. Run the command <i>yarprun --server /node</i> from the same directory of the binaries and then launch in a row first the
modules in <i>robot_server_solver.xml</i> and soon afterwards the modules in <i>client.xml</i>.
*/

