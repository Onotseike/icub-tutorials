/**
@page icub_anyrobot_cartesian_interface Customizing the Cartesian Interface for a Generic Robot

\author Ugo Pattacini

This tutorial will guide the user through the steps required to run all the components of the Cartesian Interface
with the purpose of controlling a generic yarp-compatible robot limb in its operational space. Therefore, this is
a somewhat advanced topic which might be of interest just for developers who want to adopt this interface for their
platforms, or for those of you who are really geek inside :). \n
For "normal" people - who have only iCub in their work life - the tutorial on the \ref icub_cartesian_interface
"Cartesian Interface" is extensive; it is also a prerequisite for proceeding further.


\section sec_architecture The Architecture

The architecture of the Cartesian Interface is sketched out below.

\image html cartIFArchitecture.jpg

We already know there is a <b>solver</b> in charge of inverting the kinematics, a <b>server</b> controlling the robot
limb and finally a <b>client</b> enabling the user to forward requests for cartesian movements directly from within
the code through typical calls to C++ methods. \n
However, the diagram is more informative than that: it tells us about how these three components are arranged in the
iCub network, an allocation that should be preserved also for your robot's architecture to achieve fast and reliable
performances. Here follow the details. \n
- The solver is the most computational demanding tool; for this reason it should be launched on a powerful machine
  belonging to the cluster of PCs connected to the robot network. It employs Ipopt for nonlinear optimization and
  should not be a burden to any critical routine that has to control the robot in real-time. \n
  Nonetheless, having a powerful computer as own resource, the solver can tackle the inverse kinematics problem with
  a large number of degrees-of-freedom in near real-time (something like ~20 ms).
- The server is a canonical controller responsible for sending velocity commands to the robot with the purpose of
  achieving the joints configuration as found by the solver. It is a light-weight program so that it can run directly
  onboard the robot hub; it collects the requests coming from all the clients, it asks the solver to do its job and
  feeds back clients with useful information such as the current end-effector pose.\n
  The main reason why the server should be running on the hub is that the lag due to the communication must be reduced
  as much as possible since a lag in the control loop will inevitably cause for instance unwanted overshoots in the
  response. As final suggestion, consider placing the server physically close to the robot, that is where fast ethernet
  link ends (and yarp too) and the internal robot bus begins (e.g. CAN); for iCub indeed, the server runs aboard the
  PC104.
- The client simply lives inside the user code, making queries to the server through yarp ports, thus it never speaks
  to the solver. There are no special needs for it: the location of the client depends only on the requirements of the
  user code; a program that opens up a client may run on a shuffle PC so as on a powerful machine or even aboard the
  robot hub.


\section sec_dependencies Dependencies

Besides the "classical" dependecies you need to have in order to compile all the components (<a href="http://eris.liralab.it/wiki/Installing_IPOPT">Ipopt</a>,
\ref iKin, \ref servercartesiancontroller, \ref clientcartesiancontroller; you should know them very well by now :),
you are required to accomplish a preliminary job: it can be tedious (I realize it when I had to write the "fake" stuff :)
but is mandatory. You have to provide some low-level yarp motor interfaces that are necessary for the cartesian components
to start and operate correctly. They are only three: <b>IControlLimits</b>, <b>IEncoders</b>, <b>IVelocityControl</b>.
The former two serve to get the number of joints, their actual range along with current joints configuration which is fed
back to the controller; the latter is obviously employed to send velocity profiles to the robot. \n
This is not the right place where to tell about how to deal with these interfaces, but please find out more on the topic
of making a new device in yarp <a href="http://eris.liralab.it/wiki/Making_a_new_device_in_YARP">here</a>.


\section sec_custom_example Customization Example

Let's explain how to configure all the components for your robot through an example, whose code is available under
\code
tutorials/src/anyRobotCartesianInterface.
\endcode
Imagine you're done with coding the basic motor interfaces for your robot, which is not as cute as iCub: it is equipped
indeed with just three degrees-of-freedom represented by three joints controlled by three independent motors. You'll probably
end up having something similar to the library <i>fakeMotorDevice</i> I wrote for our artifact. It contains the server and
client implementations of such motor interfaces: again, the IControlLimits, the IEncoders and the IVelocityControl.
Of course we would need now a program that simulates our fake manipulator together with the server layer that exposes a
yarp access to it. Here it is: it's called <i>fakeRobot</i> and instantiates three motors that are embodied as pure integrators
that give back joints positions once fed with joints velocities. \n
The relevant code snippet of this instantiation is located within the file <i>fakeMotorDeviceServer.cpp</i> and resumed here
for your convenience:
\code
Matrix lim(3,2);
lim(0,0)=-180; lim(0,1)=180;                    // joint 0 bounds [deg]
lim(1,0)=-90;  lim(1,1)=90;                     // joint 1 bounds [deg]
lim(2,0)=-45;  lim(2,1)=45;                     // joint 2 bounds [deg]

Vector q0;                                      // create a starting configuration q0
for (int i=0; i<lim.rows(); i++)
    q0.push_back((lim(i,0)+lim(i,1))/2.0);

motors=new Integrator(0.001*Ts,q0,lim);         // Ts is the period expressed in [ms]
\endcode
Aside from the details of the <i>Intergator</i> class (it is provided by the \ref ctrlLib library), it is worth noticing here
how the joints have bounds defined by the matrix <i>lim</i>.

Now, since you're so motivated, you've already got the kinematic description of the manipulator from your colleague who's hooked
on mechanics. You have to provide the conventional Denavit-Hartenberg table of links properties as done for the fake robot in the
file <i>app/conf/kinematics.ini</i>:
\code
numLinks 3      // number of revolute links: currently, iKin does not handle prismatic links

link_0 (A 1.0) (D 0.0) (alpha 0.0) (offset 0.0) (min -180.0) (max 180.0)
link_1 (A 1.0) (D 0.0) (alpha 0.0) (offset 0.0) (min -180.0) (max 180.0)
link_2 (A 1.0) (D 0.0) (alpha 0.0) (offset 0.0) (min -180.0) (max 180.0)
\endcode
The meaning of these parameters is described in the \ref iKinLink class; by the way they are easily recognized as the link length
(<i>A</i> in [m]), the link offset (<i>D</i> in [m]), the link twist (<i>alpha</i> in [rad]) and so on: please visit the wiki
<a href="http://eris.liralab.it/wiki/ICubForwardKinematics">page</a> on kinematics for a deeper insight. \n
A careful reader should have not missed the expression for the joints limits, which here can definitely take whatever values for all
the three joints, much different from the bounds assigned to the real joints and hard-coded within the fake motor device.
Do not worry about that: at start-up the solver will query the low-level interface (namely <i>IControlLimits</i>) about the actual
joints range and will update the kinematic structure accordingly. Later on, the server will get upgraded with a similar request
to the solver. \n

At this stage we are happy with the kinematics, so let's continue with the components configuration.


\section sec_solver_configuration Configuring the Solver

What is required here is only to inherit a new class from the iKin superclass <b>CartesianSolver</b> and then override the method
<i>getPartDesc()</i> which is responsible for describing all the parts used by the solver. \n
Essentially, you have to do three things:

The initial configuration of the solver is established by the parameters provided from within the file <i>solver.ini</i> and listed
just below. However, these values can be easily modified through calls to the cartesian interface methods.
\code
robot          fake_robot               // the name of the robot to connect to
name           solver                   // the name of the solver as seen in yarp network
period         30                       // the period of the solver in [ms]
dof            (1 1 1)                  // the list of links status as they'll start off: if blocked(0) or dofs(1) - see iKin doc
rest_pos       (0.0 0.0 0.0)            // the joints resting positions as secondary task for the solver
rest_weights   (0.0 0.0 0.0)            // the weights of resting positions (0.0 means do not take that joint into account)
pose           full                     // [full] or [xyz] for position+orientation or just position
mode           shot                     // [shot] or [cont] for tracking mode off/on
verbosity      off                      // self-explaining :)
maxIter        200                      // stop solving whenever you overcome this limit
tol            0.0001                   // tolerance for the task
xyzTol         0.00000001               // tolerance for attaining in position [m^2]
interPoints    off                      // if [on] the points discovered while converging are provided as well: they might be not so adjacent
ping_robot_tmo 10.0                     // at start-up, while connecting to the robot, wait for this timeout in [s] before giving up
\endcode
This file is loaded by the module and passed to the <i>getPartDesc()</i> method of the class.




... to be continued






\section sec_final_notes Finals Notes about Compiling the Example

The example has been designed according to the packaging policy we pursue for iCub-based application: there is a <i>src</i> directory
filled with the library and the code and then there is an <i>app</i> directory containing the configuration files and the scripts
to run the binaries. Therefore, just create the <i>anyRobotCartesianInterface/build</i> directory (be always neat and divide the code
from the compilation produts :), go there and launch the <i>ccmake ../</i> command. After the compilation you'll end up having the
directory <i>anyRobotCartesianInterface/bin</i> where all the binaries will be copied in along with the configuration files and the
xml scripts. Before launching in a row first the <i>robot_server_solver.xml</i> and soon afterwards the <i>client.xml</i>, please
run the command <i>yarprun --server /node</i> from the same directory of the binaries.


